---
title: JavaScript--面向对象
tags:
- js
- 面向对象
---

>ECMAscript中，对象是无序属性的集合，其属性包含基本值，对象或者函数

### 面向对象的特点
`封装`  `继承`  `多态`

**依附于对象的变量叫属性，依附于对象的函数叫方法**

### 创建对象的方式
1、`工厂模式`，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象；
2、`构造函数模式`，创建自定义引用类型，可以像创建内置对象实例一样使用new操作符，这种方式的特点是--构造函数的每个成员都无法复用，每次创建出的对象只有私有变量和私有方法，不能实现公用；
3、`原型模式`，使用构造函数的prototype属性来指定共享的属性和方法，即使用构造函数定义实例属性，使用原型定义共享的属性和方法；
<!--more-->
#### 工厂模式
在函数内创建一个对象，给对象赋予属性及方法再将对象返回即可；
```javaScript
function human(theName, theAge) {
    var person = new Object();
    person.name = theName;
    person.age = theAge;
    person.say = function() {
        console.log("hello", this.name, this.age)
    }
    return person
}

human("hehe", 19).say();//hello hehe 19
```
如上，工厂模式解决了创建多个相似对象的问题，但是工厂模式却无法识别对象的类型，因为全部都是Object，不想Date、Array等，因此出现了构造函数模式；
#### 构造函数模式
ECMAScript中构造函数可以创建特定类型的对象，类似于Array、Date等原生JS的对象；
```javaScript
function Human(theName, theAge) {
    this.name = theName;
    this.age = theAge;
    this.say = function() {
        console.log("hello", this.name, this.age)
    }
}

var person = new Human("hehe", 19);
person.say();//hello hehe 19
console.log(person instanceof Human); //true
```
如上，构造函数模式相比于工厂模式，具有如下特点：

1. 函数名首写字母为大写（虽然标准没有严格规定首写字母为大写，但是按照惯例，构造函数的首写字母用大写）；
2. 没有显示的创建对象；
3. 直接将属性和方法赋值给了this对象；
4. 没有return语句；
5. 使用new创建对象；
6. 能够识别对象（这正是构造函数模式胜于工厂模式的地方）；

然而，构造函数也存在缺点，每次创建实例的时候都要重新创建一次方法，因为理论上每次创建对象的时候对象的属性均不同，而对象的方法是相同的，然而创建两次完全相同的方法是没有必要的，因此，可以将函数移到对象外面；
```javaScript
function Human(theName, theAge) {
    this.name = theName;
    this.age = theAge;
    this.say = say;

}

function say() {
    console.log("hello", this.name, this.age)
}

var person = new Human("hehe", 19);
person.say(); //hello hehe 19
console.log(person instanceof Human); //true
```
以上改动虽然避免了重复创建方法，但是却在全局作用域中定义了许多仅供特定对象使用的方法，浪费空间不说，而且也失去了面向对象的封装性了，因此可以通过原型来解决此问题；

#### 原型模式
我们创建的每个函数都有prototype(原型)属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法；

使用原型对象的优点就是可以让所有对象实例共享它所包含的属性和方法；

原型模式的缺点则在于，它省略了构造函数传递初始化参数这一环节，结果所有实例在默认情况下都取得了相同的属性值，而且由于它所具有的共享的特性，使得如果一个实例修改了引用，另一个实例也会随之更改；

所以我们通常不单独使用原型，而是结合原型模式与构造函数模式；
```javaScript
function Human(theName, theAge) {};

Human.prototype.name = "hehe";
Human.prototype.age = 19;
Human.prototype.say = function() {
    console.log("hello", this.name, this.age)
}

var person = new Human("hehe", 19);
person.say();//hello hehe 19
```
#### 混合模式（原型模式+构造函数模式）
```javaScript
function Human(theName, theAge) {
    this.name = theName;
    this.age = theAge;
}

Human.prototype.say = function() {
    console.log("hello", this.name, this.age)
}

var person = new Human("hehe", 19);
person.say(); //hello hehe 19
console.log(person instanceof Human); //true
```
混合模式中的构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性，这样就能让每个实例都会有自己的实例属性，但同时又共享着方法，最大限度的节省了内存，另外这种模式还支持传递初始参数；
#### 动态原型模式
动态原型模式将所有的信息封装在了构造函数中，而通过构造函数中初始化原型（仅第一个对象实例化时初始化原型），可以通过判断该方法是否有效而选择是否需要初始化原型；
```javaScript
function Human(theName, theAge) {
    this.name = theName;
    this.age = theAge;

    if (typeof this.say != 'function') {
        console.log("初始化原型")
        Human.prototype.say = function() {
            console.log("hello", this.name, this.age)
        }
    }
}

var person = new Human("hehe", 19);
var person2 = new Human("xixi", 20);
person.say(); 
//初始化原型
//hello hehe 19
person2.say();
//hello xixi 20
console.log(person instanceof Human); //true
```
可以看到，“初始化原型”只执行了一次，即person初始化原型后，person2就不需要再次初始化原型了；

#### prototype
每一个函数都具有一个prototype属性，该属性是一个属性，指向一个对象，此对象将会被有构造函数创建的对象实例所共享，也就是会继承此对象；
#### 原型链
原型链是一种机制，指的是JavaScript每个对象包括原型对象都有一个内置的[[proto]]属性指向创建它的函数对象的原型对象，原型链的存在就是为了实现对象的继承；
#### 原型对象
当应以一个函数兑现的时候，会包含一个叫prototype预定义的属性，它就是原型对象；

`__proto__`
JavaScript在创建的对象实例，都会有一个[[proto]]的内置属性，用于指向创建它的构造函数的prototype原型对象，原型对象也有[[proto]]属性，因此在不断的指向中，形成了原型链；

`constructor`
原型丢向prototype都有个预定义的constructor属性，用来引用它的函数对象，这是一种循环引用；

#### Global全局对象
**编码方式**
`escape()` 对字符串进行编码，可以在所有计算机上读取该字符串
`encodeURI()` 把字符串作为URI进行编码
`encodeURIComponent()` 把字符串作为URI组件进行编码

**解码方式**
`decodeURI()` 解码编码的URI
`decodeURIComponent()` 对encodeURIComponent()函数编码的URI进行解码

### JavaScript中自带的对象
`Object` `String` `Number` `Date` `Array` `Boolean` `Math` `Global`


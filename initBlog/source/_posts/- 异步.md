---
title: ES6--异步
tags:
- es6
- async
- 异步
---
>由于js的执行环境是单线程的，所以异步操作尤为重要；
>异步操作通俗的讲，就是将一件事情分为两个阶段来执行，存在一个先后顺序；

### ES5中的异步方式
 - 回调函数
 - 发布订阅
 - 事件监听
 - Promise对象（Promise在ES6之前是自定义实现的，并没有被标准化）
<!--more-->
### ES6新增的异步编程方式
 - Promise对象（标准化之后）
 - Generator函数
### 常用方式的优缺点
`回调函数`显然是不可取的，这种方式本身没有问题，但是代码的可读性很差，如果是多层嵌套简直是一场灾难；

`Promise`相对于回调函数可以说是非常不错的，使用`Promise`对象可以实现链式调用，而不是层层嵌套，但是如果异步操作很多的话，`then`、`catch`等方法必然会大量出现，所以也会导致逻辑不清楚；

`Generator`会将执行权移出`Generator`函数，并且可以使用`next()`方法再次让其获得执行权，使用`Generator`函数可以使流程更加清晰，但是缺点也很明显，就是无法自动将异步操作全部执行完毕(当前可以使用`co模块`解决)；
```javaScript
var gen = function* (){
  var f1 = yield readFile(fileA);
  var f2 = yield readFile(fileB);
};
var co = require("co");
co(gen);
```
### async函数(ES7)
`async`是js异步操作比较完美的解决方案，同事具有`Promise`对象和`Generator`函数的优点，既能避免多层嵌套，又具有逻辑清晰和自动化执行的优点；

`async`其实就是`Generator`函数的语法糖；

假设现在需要异步读取两个文件，`Generator`写法如下：
```javaScript
var gen = function* (){
    var f1 = yield readFile('文件1');
    var f2 = yield readFile('文件2');
}
```
而如果换成`async`函数，就会是下面这样：
```javaScript
var gen = async function(){
    var f1 = await readFile('文件1');
    var f2 = await readFile('文件2');
}
```
其实就是将Generator的*换成async，并放在function前面，再讲yield换成await；

`async`相对于`Generator`函数做了以下几点改进：
#### 内置执行器
`Generator`函数的执行必须依靠执行器，所以出现了`co函数库`，而`asyn`c函数自带执行器；
#### 更好的语义
`async`表示函数里有异步操作，`await`表示紧跟在后面的表达式需要等待结果；
#### 更广的适用性
`co函数库`约定，`yield`命令后面只能是`Thunk函数`或P`romise对象`，而`async`函数的`await`命令后面可以跟`Promise对象`和`原始类型`的值；

`async`是属于`ES7`的语法功能，但是`转码器Babel`和`regenerator`都已经支持，转码后就能使用；
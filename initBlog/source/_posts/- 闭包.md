---
title: JavaScript--函数
tags:
- js
- 闭包
---
### 函数语句
#### if else
这个没什么好说的，记住有时候语句中的大括号是可以省略的，免得下次看到一脸懵逼;
```javaScript
if (true == 1) console.log("yeah you are right");//yeah you are right
```
<!--more-->
缺点是只能在后面接一句，如果有多余的语句就不属于if语句了；
#### do while
do while就是先执行代码，再去判断条件是否成立，代码至少被执行一次，如果条件成立继续循环执行，否则退出循环；
```javaScript
var num = 1;
do {
    console.log(num);//1,2,3,4,5
    num++;
}
while (num < 6);
console.log(num);//6
```
#### while
while也是先判断条件是否成立，如果成立则执行语句，否则退出循环；
```javaScript
var num = 1;
while (num < 6) {
    console.log(num)//1,2,3,4,5
    num++;
};
console.log(num); //6
```
#### for
for循环是经常用的，主要需要理解的是小括号内部语句的含义；
```javaScript
for (
    var i = 0; i < 5; i++
) {
    console.log(i);//0,1,2,3,4
}
console.log(i);//5
```
以上代码语句的执行顺序如下：
1、声明一个变量i，并且初始化其值为0；
2、判断i的值是否小于5，如果小于5则执行大括号中的语句，然后再执行i++；

可以看到，最终i的结果为5，因为在i=4的时候，i仍然小于5，所以在执行完`console.log(i)`之后，会继续执行`i++`,此时i的值为5，已经不满足继续执行的条件，所以循环到此停止；

**注意** `for后面的括号中，有且只能有两个分号(;)`

for循环还可以这样用：
```javaScript
for (
    var i = 0 ,a = 1, b = 2; i < 5; i++
) {
    console.log(i); //0,1,2,3,4
}
console.log(i)
```
#### arguments对象
当函数调用的时候，会自动创建一个arguments对象，此对象存储了实际传入函数的参数；

此对象不能显式的创建，与数组相似，可以使用索引访问对象中的参数，或使用length返回参数数量；
```javaScript
function func(a) {
    for (var i = 0; i < arguments.length; i++) {
        console.log(arguments[i])
    }
    console.log(a)//1
}

func(1, 2, 3, 4)//1,2,3,4
```
如上，说明在arguments存放的是调用函数时传给函数的参数，而非函数定义的形式参数；
#### 闭包
闭包是指一个函数可以访问另一个函数作用域中的变量，创建闭包最常见的方式就是在一个函数中嵌套另一个函数，然后可以通过另一个函数访问外层函数作用域的变量；

`闭包的特点：`

 - 函数中嵌套函数
 - 嵌套的函数可以使用外层函数作用中的变量和参数
 - 参数和变量不会被垃圾回收机制回收

通常情况下，函数中声明的局部变量会在函数执行完毕后背销毁：
```javaScript
function test() {
    let a = 3;
    a++
    console.log(a)
}

test();//4
test();//4
```
如上，函数执行两次都输出4，按照test()函数的意思，在第二次执行的时候应该输出5，但是并没有，因为当前函数执行完毕后，里面的参数就被销毁了，并没有保留自增后的结果；

`闭包的优点:`

 - 局部变量长期驻扎在内存中
 - 避免全局变脸的污染
 - 私有成员的存在
 
`闭包的使用`
```javaScript
function test() {
    let a = 3;
    return function() {
        a++;
        console.log(a)
    }
}

var bi = test()
bi(); //4
bi(); //5
```
如上，代码实现了局部变量累加，但是此时的a却是一个局部变量，并不会对函数作用域外的同名变量产生污染；

总的来说，闭包的意思就是描述了函数执行完毕内存释放后，依然内存驻留的一个现象；
#### bind、call、apply区别与用法
bind()方法可以返回一个与原来函数主体相同的新函数，新函数中的this指向传入的指定对象；

apply和call都是为了改变某个函数运行时的上下文而存在的，即改变函数内部的this执行；

如果使用apply或call方法，那么this指向他们的第一个参数，apply的第二个参数是以数组的形式表达，call的第二个及以后的参数是需要单独列举的；

**将伪数组转为数组的方法**：`Array.prototype.slice.apply(argument)`

bind会创建一个新函数，称为绑定函数，当调用这个函数的时候，绑定函数会以创建它时传入bind()方法的第一个参数作为this，传入bind()方法的第二个及以后的参数，加上绑定函数运行时本身的参数，按照顺序作为原函数的参数来调用原函数；

`bind、apply、call区别：`
bind()不会立即调用，而其他两个会立即调用；

`call,apply,bind共同点:`

- 都是用来改变函数的this对象的指向的
- 第一个参数都是this要指向的对象
- 都可以利用后续参数传参

`bind()的使用：`
```javaScript
function test(a) {
    console.log(this.d); //333
    console.log(a); //111
}

let obj = {
    c: 222,
    d: 333
}

var func = test.bind(obj, 111);
func()
```
如上，将test的执行上下文变成了obj，所以test中的this指向的是obj；


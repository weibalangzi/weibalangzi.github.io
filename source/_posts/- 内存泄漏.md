---
title: JavaScript--垃圾回收机制
tags:
- js
- 垃圾回收
- 内存泄漏
---

# 垃圾回收机制

>js存在内置的垃圾回收机制，也就是说执行环境会负责管理代码执行过程中的使用的内存；js中的垃圾回收主要使用了标记清除算法和引用计数器算法。

## 标记清除算法
### 基本概念
在垃圾回收算法中，经常会出现mutator和collector两个名称；

`collector`：垃圾收集器；

`mutator`：垃圾收集器之外的部分，比如当前的应用程序；

`mutator roots`：mutator根对象，通常是分配在堆内存之外，可以直接被mutator直接访问到的对象，一般指静态、全局变量；

可到达对象：指从根对象开始遍历，可以访问到的对象，也就是mutator正在使用的对象；
<!--more-->
### 基本原理
标记清除算法可以拆分为两部分：`标记（mark）`和`清除（sweep）`；

`标记阶段`：此阶段，垃圾回收器会从mutator根对象开始遍历，每一个可以从根对象访问到的对象都会被添加一个标识，于是这个对象就被标识为可到达对象；

`清除阶段`：此阶段垃圾回收器会怼堆内存从头到尾进行线性遍历，如果发现有对象没有被标识为可到达对象，那么就将此对象占用的内存回收，并且将原来标记为可到达对象的标识清除，以便进行下一次垃圾回收操作；
### 开始回收的时间
在使用标记清除算法时，未引用对象并不会被立即回收，垃圾对象将一直累计到内存耗尽为止，当内存耗尽时，程序将会被挂起，垃圾回收开始执行；
### 标记清除算法的缺点
垃圾收集后有可能会造成大量的内存碎片；
## 引用计算器算法
### 基本概念
为每个对象增加一个字段记录被引用的次数，并在运行时跟踪和更新引用的总数；
### 基本原理
当声明一个变量并将一个引用类型值赋值该变量时，则这个值的引用次数就是1，如果同一个值又被赋值给另外一个变量，则该值的引用次数为1；

相反，如果包含对这个值的引用的变量又取得了另外一个值，则这个值的引用次数减1；

当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收；这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存；
### 计数器算法的优点
无需等待内存耗尽再执行垃圾回收操作，可以在赋值操作的同时，检查计数器是否为0，如果是的话就可以立即回收；
### 计数器算法的缺点
此算法不能解决循环引用的问题，例如，存在两个对象objA和objB，它们通过各自的属性相互引用，当函数执行完毕后，objA和objB还将继续存在，因为它们的引用次数永远不会是0；
```javaScript
function problem(){
    var objA = new Object();
    var objB = new Object();
    
    objA.someOtherObject = objB;
    objB.anotherObject = objA;
}
```
此时最好的方法是采用标记清除算法，由于函数执行之后，这两个对象都离开了作用域，所以会被标记，从而被垃圾收集器清除所占用的内存；
# 内存泄漏

>内存泄漏就是指被分配的内存既不能被使用，也不能被回收的现象；

在低版本IE浏览器中，DOM对象与JavaScript对象形成循环引用，就有可能产生内存泄漏，除非人为的切断引用；低版本IE浏览器在JavaScript对象中使用标记清除垃圾回收机制，而对于DOM对象则使用引用清除垃圾回收机制；
```javaScript
function func(){
    var elem = document.getElementById('ele');
    elem.onclick = function(){}
}
```
以上代码过程如下：

 1. elem对象通过onclick引用了匿名函数function；
 2. 匿名函数又通过作用域链引用到外部函数的变量对象，变量对象中存储有elem对象，于是形成里一个循环应用；
 
整个过程如下如所示：
![](http://www.softwhy.com/data/attachment/portal/201704/10/164802wvtznuvp3bjviq9t.png)

### 常见的内存泄漏的原因
#### 全局变量引起的内存泄漏
```javaScript
function func(){
    test = 'aaaaa';
}
```
test会成为一个全局变量，不会被回收；
#### 闭包引起的内存泄漏
```javaScript
var func = (function() {
    var test = "hehe";
    return function() {
        console.log(test)
    }
})()
```
test被闭包所引用，不会被回收；
#### dom清空或删除时，事件未清除导致内存泄漏
```javaScript
$('elem').bind('click',function(){
    console.log('aaaaa')
}).remove()
```
elem还会存在于内存中
```javaScript
$('elem').bind('click',function(){
    console.log('aaaa')
}).off('click').remove()
```
在事件被清除后，elem即可从内存中移除；
#### 子元素存在引用导致的内存泄漏
![](http://staticc.qiniudn.com/detached-nodes.gif)
黄色是指直接被 js变量所引用，在内存里；
红色是指间接被 js变量所引用，如上图，refB 被 refA 间接引用，导致即使 refB 变量被清空，也是不会被回收的；
子元素 refB 由于 parentNode 的间接引用，只要它不被删除，它所有的父元素（图中红色部分）都不会被删除；





